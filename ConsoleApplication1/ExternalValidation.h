#pragma once
#ifndef EXTERNALVALIDATION_H
#define EXTERNALVALIDATION_H

#include "Point.h"
#include <vector>	// Vector class
#include <numeric>	// Accumulate
#include <iostream>	// Output
#include <cmath>	// Square root

using namespace std;

class ExternalValidation : public Point
{
private:
	double	true_positives,
		false_negatives,
		false_positives,
		true_negatives;
	int clusters, points;		// # of clusters, # of points
	vector<vector<int> > contingencyTable;
	vector<int> row_sums;
	vector<int> column_sums;

public:

	ExternalValidation() {
		true_positives = 0.0;
		false_negatives = 0.0;
		false_positives = 0.0;
		true_negatives = 0.0;
		clusters = 0;
		points = 0;
	}
	ExternalValidation(int clusters, int points) {
		true_positives = 0.0;
		false_negatives = 0.0;
		false_positives = 0.0;
		true_negatives = 0.0;

		this->clusters = clusters;
		this->points = points;
		// For K number of clusters (K-means) and K number of partitions
		// (ground truth) create a K x K matrix
		contingencyTable = vector<vector<int> >(clusters, vector<int>(clusters, 0));
		row_sums = vector<int>(clusters, 0);
		column_sums = vector<int>(clusters, 0);
	}

	void calculateTable(vector<Point>* allPoints) {
		for (int i = 0; i < points; i++) {
			// The cluster assignment generated by K-means
			int clusterId = (*allPoints)[i].getCluster();
			// The partition assignment given by ground truth info
			int partitionId = (*allPoints)[i].getPartition();

			contingencyTable[clusterId][partitionId] += 1;
		}


		for (int i = 0; i < clusters; i++) {
			for (int j = 0; j < clusters; j++) {
				// Sum of row
				row_sums[i] += contingencyTable[i][j];
				// Sum of columns
				column_sums[j] += contingencyTable[i][j];
			}
		}

		// Check that the sum total of ni = sum total of mj = n
		if (accumulate(row_sums.begin(), row_sums.end(), 0) != points) {
			cout << "Error: sum of rows does not equal n" << endl;
		}
		if (accumulate(column_sums.begin(), column_sums.end(), 0) != points) {
			cout << "Error: sum of column does not equal n" << endl;
		}
	}
	void calculateMeasures() {
			// True Positive: pairs of points with the same cluster label
			// and partition label
		for (int i = 0; i < clusters; i++) {
			for (int j = 0; j < clusters; j++) {
					double nij = (double)contingencyTable[i][j];
					true_positives += nij * nij;
			}
		}

		true_positives = (true_positives - points) / 2.0;

			// False Negative: belong to the same partition but not the
			// same cluster
		for (int j = 0; j < clusters; j++) {
				false_negatives += (double)column_sums[j] * column_sums[j];
		}

		false_negatives = (false_negatives / 2.0) - true_positives;

			// False Positive: belong to the same cluster but not the
			// same partition
		for (int i = 0; i < clusters; i++) {
			false_positives += (double)row_sums[i] * row_sums[i];
		}

		false_positives = (false_positives / 2.0) - true_positives;

			// True Negative: don't belong to the same cluster or the
			// same partition
		true_negatives = (((double)points * points) / 2.0) - (true_positives + false_negatives + false_positives);
	}

	double randIndex() {
		return (true_positives + true_negatives) / (true_positives + true_negatives + false_positives + false_negatives);
	}

	/* Jaccard Coefficient is similar to the Rand Index, but ignores
		the true negatives.
	*/
	double jaccardCoefficient() {
			return true_positives / (true_positives + false_negatives + false_positives);
	}

	/* Fowlkes-Mallows is the geometric mean of the precision and recall
		Precision: the fraction of true or correctly clustered point pairs
		compared to all the point pairs in the same cluster
		Recall: the fraction of correctly labeled point pairs compared
		to all the point pairs in the same partition
	*/
	double fowlkesMallows() {
		double precision = true_positives / (true_positives + false_positives);
		double recall = true_positives / (true_positives + false_negatives);

		return sqrt(precision * recall);
	}
	
};
#endif 